/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.jetbrains.teamcity

import com.jetbrains.teamcity.common.MathUtils
import java.lang.IllegalArgumentException
import com.jetbrains.teamcity.common.constants.ValidationConstants
import com.jetbrains.teamcity.docker.DockerImage
import com.jetbrains.teamcity.docker.hub.DockerRegistryAccessor
import com.jetbrains.teamcity.docker.hub.data.DockerhubImage
import com.jetbrains.teamcity.docker.validation.ImageValidationUtils
import com.jetbrains.teamcity.teamcity.TeamCityUtils
import kotlinx.cli.*
import java.lang.IllegalStateException


/**
 * Subcommand for image validation. Will be consumed by ..
 * ... argument parser.
 */
@OptIn(ExperimentalCli::class)
class ValidateImage: Subcommand("validate", "Validate Docker Image") {
    private val imageNames by argument(ArgType.String, description = "Images").vararg()

    /**
     * Execute image validation option specified via CLI.
     */
    override fun execute() {
        if (imageNames.size > 2) {
            throw IllegalArgumentException("Too many image names")
        }

        // 1. Capture current image size
        val registryAccessor = DockerRegistryAccessor("https://hub.docker.com/v2")
        val currentImage = DockerImage(imageNames[0])

        var imagesFailedValidation = ArrayList<DockerhubImage>()

        // -- all images associated with registry-tag pair
        val originalImageRegistryInfo = registryAccessor.getRegistryInfo(currentImage)
        originalImageRegistryInfo.images.forEach { image ->
            // -- report size for each image
            // TODO: update documentation with "OS" reference
            TeamCityUtils.reportTeamCityStatistics("SIZE-${ImageValidationUtils.getImageStatisticsId(currentImage.toString())}-${image.os}", image.size)

            // -- compare image
            // TODO: Change "!!" operators to proper comparison
            val imagesMatchingPrevious: List<DockerhubImage> = registryAccessor.getPreviousImages(currentImage, image.os, image.osVersion) ?: return@forEach
            if (imagesMatchingPrevious.size != 1) {
                throw IllegalStateException("Unable to determine the image matching previosu one.")
            }

            val previousImage = imagesMatchingPrevious.first()
            if (MathUtils.getPercentageIncrease(image.size.toLong(), previousImage.size.toLong()) > ValidationConstants.ALLOWED_IMAGE_SIZE_INCREASE_THRESHOLD_PERCENT) {
                imagesFailedValidation.add(image)
            }
        }

        // TODO: Print out non-qualified images here
        imagesFailedValidation.forEach {
            println("Validation failed for ${it.os}")
        }

        // TODO: Ensure target OS and OS Version are equal
//        val previousImageSize = registryAccessor.getSizeOfPreviousImage(currentImage, "linux")
//        if (previousImageSize == null) {
//            println("Unable to find previous version of image within registry: $currentImage")
//            return
//        }
//
//
//        // 3. Compare the sizes
//        if (percentageIncrease > ValidationConstants.ALLOWED_IMAGE_SIZE_INCREASE_THRESHOLD_PERCENT) {
//            throw DockerImageValidationException("Image $currentImage size compared to previous ($previousImageSize) " +
//                    "suppresses ${ValidationConstants.ALLOWED_IMAGE_SIZE_INCREASE_THRESHOLD_PERCENT}% threshold.")
//        }
    }
}

@OptIn(ExperimentalCli::class)
fun main(args: Array<String>) {

    val parser = ArgParser("automation")
    val imageValidation = ValidateImage()
    parser.subcommands(imageValidation)

    // Splitting arguments into a list as the "--args" options might be treated as a ...
    // ... single string in non-interactive terminals, thus the parsing could be done incorrectly. ...
    // ... "\\s" is used to also cover non-unicode whitespaces.
    val argsList: Array<String> = if (args.size > 1) args else args[0].split("\\s+".toRegex()).toTypedArray()
    parser.parse(argsList)
}
